#lang scribble/manual

@(require 1/lang scribble/example scribble/core scribble/racket
          (for-label (except-in 1/all-base ложь)))

@title{Русский язык программирования Ади́на}
@author[(author+email "Клочков Роман" "kalimehtar@mail.ru")]

@section[#:tag "like Racket"]{Отличия от Racket}

Эта глава предназначена для тех, кто умеет программировать на Scheme и/или Racket. Остальные
могут её пропустить и перейти к @seclink["essentials" "следующей"].

На Адине можно писать как на Racket с упрощённым синтаксисом. Обратная совместимость
поддерживается почти полностью,
за исключением строчных комментариев и квадратных и фигурных скобок. Если в Racket
использовалась «;», то здесь для строчных комментариев необходимо использовать
«@tt{-}@tt{-}», так как «;» используется в других синтаксических конструкциях,
которые будут описаны ниже. Квадратные и фигурные скобки также нельзя использовать вместо круглых,
так как они несут другой синтаксический смысл.

То есть, например, программа

@codeblock|{
  #!1
  (letrec ((is-even? (lambda (n)
                       (or (zero? n)
                           (is-odd? (sub1 n)))))
           (is-odd? (lambda (n)
                      (and (not (zero? n))
                           (is-even? (sub1 n))))))
    (is-odd? 11))
}|

будет также, как и в Racket, возвращать #t. Но этот язык позволяет сделать списки, из которых
состоит программа на Racket, читабельней.
В нём структуру списка можно обозначить не скобками, а отступами. Список можно записать как
@codeblock{
  #!1
  список 1 2 3 4 5 6
}
или как
@codeblock{
 #!1
 список 1 2 3 4
    5
    6
}
Функция @racket[список] --- синоним функции @racket[list].

Если на одной строке есть несколько элементов, разделённых пробельными литерами, то это список.
Если следующая строка начинается с большего отступа, чем текущая, то это элемент текущего
списка, если отступ текущей строки равен отступу предыдущей,
которая является элементом списка, то эта строка также элемент того же списка.

Для иллюстрации запишу @racket[(список 1 2 (список 3 4) 5 (список 6 (список 7 8)))]
@codeblock{
  #!1
  список 1 2
    список 3 4
    5
    список 6
      список 7 8
}

Также есть специальная конструкция для списков, первым элементом которых тоже является список.
В этом случае для дополнительного отступа можно использовать «;». Либо её же можно использовать
для разделения списка на подсписки.

Например,
@codeblock{
  (let ((x 1) (y 2))
    (f x y))
}
можно записать как
@codeblock{
  #!1
  let
    ;
      x 1
      y 2
    f x y
}
или как
@codeblock{
  #!1
  let (x 1; y 2)
    f x y
}

Синтаксическое правило выглядит так: если в списке встречается «;», то список разделяется на
подсписки, как если бы
вместо «;» был перенос строки с сохранением отступа.

Таким образом, последовательности элементов «x 1» и «y 2» становятся вложенными списками.

Запишем предыдущий пример, описывая структуру программы отступами
@codeblock|{
  #!1
  letrec
    ;
      is-even?
        lambda (n)
          or
            zero? n
            is-odd?
              sub1 n
      is-odd?
        lambda (n)
          and
            not
              zero? n
            is-even?
              sub1 n
    is-odd? 11
}|

Есть ещё одна синтаксическая конструкция, заимствованная из Haskell, позволяющая сократить
количество строк не добавляя скобок. Литера «$» показывает, что
элементы справа от него являются списком, который должен быть подставлен на место этой литеры.

@racket[(список 1 2 (список 3 4) 5 (список 6 (список 7 8)))] теперь можно записать как

@codeblock|{                              
  #!1
  список 1 2
    список 3 4; 5
    список 6 $ список 7 8
}|

А пример из Racket как
@codeblock|{
  #!1
  letrec
    ;
      is-even? $ lambda (n)
        or
          zero? n
          is-odd? $ sub1 n
      is-odd? $ lambda (n)
        and
          not $ zero? n
          is-even? $ sub1 n
    is-odd? 11
}|

Таким образом получаем наглядное представление программы, которое не перегружено скобками.

Для упрощения чтения программы также добавлено ещё несколько синтаксических конструкций,
которые позволяют сделать текст программы
более похожим на широко распространённые языки программирования.

Если перед скобкой нет пробела, то включается особый алгоритм обработки. Для круглой скобки
элемент перед скобкой добавляется в голову списка.
Элементы внутри спиcка можно (но не обязательно) разделять при помощи «;».

@racket[(список 1 2 (список 3 4) 5 (список 6 (список 7 8)))] можно выразить как
@codeblock|{
#!1
список(1; 2; список 3 4; 5; список 6 $ список 7 8)
}|

Так можно записывать в одну строку вызовы функций с аргументами, которые являются вызовами
функций. Кроме того, таким образом удобно вызывать каррированные функции
Вместо @racket[(((f 5) 6) 7)] будет
@racket[#,(elem (racket f) (racket (5)) (racket (6)) (racket (7)))].

Для квадратной скобки конструкция преобразуется в инструкция
доступа к коллекции (массиву/списку/хэшу).

Вместо @racket[(vector-ref a 5)] можно просто писать @racket[#,(elem (racket a) (racket [5]))].
А вместо @racket[(vector-ref (vector-ref a 5) 6)] ---
@racket[#,(elem (hspace 1) (racket a) (racket [5]) (racket [6]))].

При помощи фигурных скобок есть возможность вызвать методы объекта.

@racket[(send window show #t)] можно записать как @racket[window]@racket[{show #t}].
Также можно использовать несколько вызовов как в @racket[send+].

@codeblock{
(send* (new point%)
 (move-x 5)
 (move-y 7)
 (move-x 12))
}

преобразуется в
@codeblock|{
#!1
new(point%){move-x 5; move-y 7; move-x 11}
}|
или
@codeblock|{
#!1
new(point%){move-x(5) move-y(7) move-x(11)}
}|

Для удобства работы с арифметикой реализованы приоритеты бинарных операций.
Если в списке обнаружена бинарная операция, то она становится в голову списка и получает элементы
до и после неё как два аргумента-списка. Операцией считается любой индентификатор,
который состоит только из @litchar{!#$%&⋆+./<=>?@"@"^~:*-} и не равен @litchar{...}.
Любой другой идентификатор можно
сделать оператором добавив перед и после него литеры @litchar{^}. Например, @racket[(2 ^cons^ 3)]
то же самое, что @racket[(cons 2 3)].

Если надо, чтобы операция оставалась аргументом, то пишите её как список из точки и операции.
Например, если надо написать @racket[(list + 3)], то можно написать
@codeblock{
#!1
list (. +) 3
}

Оператор равенства реализован как == (вместо @racket[equal?]) и === (вместо @racket[eqv?]),
также реализованы // (как @racket[quotient]), /= (неравно), ||, &&, % (как @racket[remainder]).

@racket[(+ (vector-ref a 5) (* 2 (hash-ref h 'key)))] можно написать как
@codeblock{
#!1
a[5] + 2 * h['key]
}

Внимание: пробелы вокруг операций обязательны, так как @racket[2*h],
например, является нормальным именем переменной.

При помощи операций вышеупомянутый пример можно записать так:
@codeblock|{
#!1           
letrec
  ;
    is-even? $ lambda (n)
      n === 0 || is-odd? (n - 1)
    is-odd? $ lambda (n)
      n /= 0 && is-even? (n - 1)
  is-odd? 11
}|
